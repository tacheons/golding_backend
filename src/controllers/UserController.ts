import { Request, Response, NextFunction } from "express";
import { UserService } from "../services/UserService";
import { User } from "../entities/User";
import { HTTPStatus } from "../modules/objects/HTTPStatus";
import * as bcrypt from "bcrypt";
import { Utils } from "../modules/classes/Utils";

/**
 * @implementaionNote
 * UserController is the main controller for all route related to user and
 * it's integrated with the UserService to process all user related
 * requests
 *
 * @return
 * various methods returns values
 *
 * @author
 * @since
 * v1.0.0
 */
export class UserController {
  private userService = new UserService();
  constructor() {
    // this.userService = new UserService();
  }

  /**
   * @implementaion
   * This method services routes that is use to fetch all users
   *
   * @params {*} void
   * @return users
   *
   * @author
   * @since
   * v1.0.0
   */
  async all(req: Request, res: Response, next: NextFunction) {
    const users = await new UserService().all();
    res.status(HTTPStatus.SUCCESSFUL.OK).json(users);
  }

  /**
   * @implementaion
   * This method fetch just one user using the user id
   *
   * @params {*} req, res, next
   * @return user
   *
   * @author
   * @since
   * v1.0.0
   */
  async one(req: Request, res: Response, next: NextFunction) {
    const id = parseInt(req.params.id);

    try {
      const user = await this.userService.one(id);

      if (!user) {
        return res
          .status(HTTPStatus.CLIENT_ERROR.NOT_FOUND)
          .json({ error: "user not found" });
      }
      return res.status(HTTPStatus.SUCCESSFUL.OK).json(user);
    } catch (error) {
      console.log(error);
      res
        .status(HTTPStatus.SERVER_ERROR.INTERNAL_SERVER_ERROR)
        .json({ error: "internal server error, please contact the admin" });
    }
  }

  /**
   * @implementaion
   * This method saves the user and return it to the saved data
   * it use bcrypt to hash the user password before saving it to the
   * database.
   *
   * The data is that is returned to the user is cutomized to to have
   * only the user id and authentication token generated by jwt
   * digital signature and subsequent user request authentication
   *
   * @params {*} req, res, next
   * @return user
   *
   * @author
   * @since
   * v1.0.0
   */
  async save(req: Request, res: Response, next: NextFunction) {
    let user = Object.assign(new User(), req.body);
    console.log(req.body);
    //password encryption
    let saltRounds = 10;
    bcrypt.hash(user.password, saltRounds, async (err, hashedPassword) => {
      // Store hash in your password DB.
      user.password = hashedPassword;
      // let userService = new UserService();

      try {
        let result = await new UserService().save(user);

        /**
         * client customized data use for authentication in the client site
         */
        let clientAuthData = {
          token: await new Utils().createToken(result.id),
          id: result.id,
        };
        res.status(HTTPStatus.SUCCESSFUL.OK).json(clientAuthData);
      } catch (error) {
        /**
         * handle server errors
         */
        console.log(error);
        if (error.code === "ER_DUP_ENTRY") {
          res
            .status(HTTPStatus.CLIENT_ERROR.CONFLICT)
            .json({ error: "user already exist" });
        } else {
          res
            .status(HTTPStatus.CLIENT_ERROR.CONFLICT)
            .json({ error: "unable to save user" });
        }
      }
    });
  }

  /**
   * @implementaion
   * This method removes user from the database
   *
   * @params {*} req, res, next
   * @return user
   *
   * @author
   * @since
   * v1.0.0
   */
  async remove(req: Request, res: Response, next: NextFunction) {
    const id = parseInt(req.params.id);

    await this.userService.remove(id);

    return "user has been removed";
  }
}
